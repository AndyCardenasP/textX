from __future__ import unicode_literals
import textx
from textx.scoping import Postponed
from textx.scoping.providers import default_name_resolver_of_model_object
from textx.scoping.tools import resolve_model_path


MyLanguage = r"""
    Model
        :   (locations+=Location)*
            (employees+=Employee)*
            (positions+=Position)*
            (projects+=Project)*
        ;

    Project
        :   'project' name=ID
            ('{'
                ('use' use=[Position])*
            '}')?
        ;

    Position
        :   'define' 'position' employee=[Employee|FQN]
            '->' location=[Location|FQN] ('as' name=ID)?
        ;

    Employee
        :   'employee' name=ID
        ;

    Location
        :   'location' name=ID
            ( '{'
                (sub_location+=Location)+
            '}')?
        ;

    FQN
        :   ID('.' ID)*
        ;

    Comment:
      /\/\/.*$/
    ;
"""

MyCode = """
    location Building
    {
        location Entrance
        location Exit
    }

    employee Hans
    employee Juergen

    // Shall be referred to with the given name: "EntranceGuy"
    define position Hans->Building.Entrance as EntranceGuy
    // Shall be referred to with the autogenerated name:
    //    <Employee>"At"<LastLocation>
    define position Juergen->Building.Exit

    project SecurityProject
    {
        use EntranceGuy
        use JuergenAtExit
    }
"""


def test_issue193_auto_name():
    meta_model = textx.metamodel_from_str(MyLanguage)

    def position_name_generator(obj):
        if obj is None:
            return None
        elif textx.textx_isinstance(obj, meta_model["Position"]):
            if obj.name is not None and len(obj.name) > 0:
                return obj.name
            location = resolve_model_path(obj, "location")
            employee = resolve_model_path(obj, "employee")
            if type(location) is Postponed or type(employee) is Postponed:
                return Postponed()
            assert location is not None and employee is not None
            return employee.name + "At" + location.name
        else:
            return default_name_resolver_of_model_object(obj)

    meta_model.register_scope_providers({
        "*.*": textx.scoping.providers.FQN(
            name_resolver_logic=position_name_generator),
    })

    model = meta_model.model_from_str(MyCode)
    assert model, "Could not create model..."
